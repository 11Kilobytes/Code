#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     motorA,        tmotorTetrix, openLoop, driveRight)
#pragma config(Motor,  mtr_S1_C1_2,     motorB,        tmotorTetrix, openLoop, driveLeft)
#pragma config(Motor,  mtr_S1_C2_1,     motorC,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorD,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    servo1,               tServoStandard)

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

void initializeRobot()
{
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

  return;
}

task main()
{
  initializeRobot();
  int threshold = 10;             //* Int 'threshold' ensures

  waitForStart();   // wait for start of tele-op phase

  while (true)
  {

  getJoystickSettings(joystick);
    if(abs(joystick.joy1_y2) > threshold)   // If the right analog stick's Y-axis readings are either above or below the threshold:
    {
      motor[motorD] = joystick.joy1_y2;         // Motor D is assigned a power level equal to the right analog stick's Y-axis reading.
    }
    else                                    // Else if the readings are within the threshold:
    {
      motor[motorD] = 0;                        // Motor D is stopped with a power level of 0.
    }


    if(abs(joystick.joy1_y1) > threshold)   // If the left analog stick's Y-axis readings are either above or below the threshold:
    {
      motor[motorE] = joystick.joy1_y1;         // Motor E is assigned a power level equal to the left analog stick's Y-axis reading.
    }
    else                                    // Else if the readings are within the threshold:
    {
      motor[motorE] = 0;                        // Motor E is stopped with a power level of 0.
    }


    // BUTTONS TO CONTOL SERVO ARM
    // Control arm via shoulder buttons, 5 and 6... 5=up, 6=down

    if(joy1Btn(5))          // If Button 5 is pressed:
    {
      servo[servo1] = 200;      // Raise Servo 1 to position 200.
    }

    if(joy1Btn(6))          // If Button 6 is pressed:
    {
      servo[servo1] = 20;       // Lower Servo 1 to position 20.
    }
    //short targetValue = //CALIBRATE VALUE
    //motorEncoder[motorC] = 0;
    //motor[E] = 50;
    //while(nmotorEncoder[motorC] < targetValue)
    //{
    //  wait1Msec(5);
    //}
    //motor[motorC] = 0;

  }
}
